"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const r=require("effect");class n extends Error{constructor(e,t,a){super(e),this.code=t,this.cause=a,this.name="AuthError"}}class u{static createPersonalAccessToken(e,t,a){return{type:"pat",providerId:e,token:t,scopes:a,validate:()=>r.Effect.sync(()=>!(!t||t.trim().length===0)),serialize:()=>({type:"pat",providerId:e,token:"***masked***",scopes:a})}}static createOAuth2(e){return{type:"oauth2",...e,validate:()=>r.Effect.sync(()=>!(!e.accessToken||e.accessToken.trim().length===0||e.expiresAt&&e.expiresAt<new Date)),serialize:()=>{var t;return{type:"oauth2",providerId:e.providerId,clientId:e.clientId,accessToken:"***masked***",refreshToken:e.refreshToken?"***masked***":void 0,expiresAt:(t=e.expiresAt)==null?void 0:t.toISOString(),scopes:e.scopes}}}}static createWeb3Wallet(e){return{type:"web3-wallet",...e,validate:()=>r.Effect.flatMap(e.getAddress(),t=>r.Effect.sync(()=>t.toLowerCase()===e.walletAddress.toLowerCase())),serialize:()=>({type:"web3-wallet",providerId:e.providerId,walletAddress:e.walletAddress,chainId:e.chainId,signature:e.signature?"***masked***":void 0,nonce:e.nonce})}}static createAESKey(e){return{type:"aes-key",...e,validate:()=>r.Effect.tryPromise({try:async()=>{const t="test-validation-data",a=await r.Effect.runPromise(e.encrypt(t));return await r.Effect.runPromise(e.decrypt(a))===t},catch:()=>new n("AES key validation failed","VALIDATION_ERROR")}),serialize:()=>({type:"aes-key",providerId:e.providerId,keyId:e.keyId,encryptedKey:"***masked***",algorithm:e.algorithm})}}static createSSHKey(e){return{type:"ssh-key",...e,validate:()=>r.Effect.sync(()=>!(!e.publicKey||e.publicKey.trim().length===0||!e.keyFingerprint||e.keyFingerprint.trim().length===0)),serialize:()=>({type:"ssh-key",providerId:e.providerId,publicKey:e.publicKey,privateKey:e.privateKey?"***masked***":void 0,passphrase:e.passphrase?"***masked***":void 0,keyFingerprint:e.keyFingerprint})}}static createBasic(e,t,a){return{type:"basic",providerId:e,username:t,password:a,validate:()=>r.Effect.sync(()=>!(!t||t.trim().length===0||!a||a.trim().length===0)),serialize:()=>({type:"basic",providerId:e,username:t,password:"***masked***"})}}static createAnonymous(e){return{type:"anonymous",providerId:e,validate:()=>r.Effect.succeed(!0),serialize:()=>({type:"anonymous",providerId:e})}}}class l{isAuthTypeSupported(e){return this.supportedAuthTypes.includes(e)}createAuthError(e,t,a){return new n(e,t,a)}validateRequiredFields(e,t){return r.Effect.sync(()=>{for(const a of t)if(!(a in e)||e[a]==null)throw new n(`Missing required field: ${a}`,"MISSING_REQUIRED_FIELD")})}getStringValue(e,t,a){const s=e[t];if(typeof s=="string")return s;if(a!==void 0)return a;throw new n(`Expected string value for ${t}, got ${typeof s}`,"INVALID_FIELD_TYPE")}getNumberValue(e,t,a){const s=e[t];if(typeof s=="number")return s;if(a!==void 0)return a;throw new n(`Expected number value for ${t}, got ${typeof s}`,"INVALID_FIELD_TYPE")}getArrayValue(e,t,a){const s=e[t];if(Array.isArray(s))return s;if(a!==void 0)return a;throw new n(`Expected array value for ${t}, got ${typeof s}`,"INVALID_FIELD_TYPE")}}class E extends l{constructor(){super(...arguments),this.providerType="github",this.supportedAuthTypes=["pat","oauth2","basic"]}createCredentials(e){return r.Effect.sync(()=>{const t=this.getStringValue(e,"type");if(!this.isAuthTypeSupported(t))throw this.createAuthError(`Unsupported auth type: ${t}`,"UNSUPPORTED_AUTH_TYPE");switch(t){case"pat":return u.createPersonalAccessToken(this.providerType,this.getStringValue(e,"token"),this.getArrayValue(e,"scopes",[]));case"oauth2":return u.createOAuth2({providerId:this.providerType,clientId:this.getStringValue(e,"clientId"),clientSecret:this.getStringValue(e,"clientSecret",""),accessToken:this.getStringValue(e,"accessToken"),refreshToken:this.getStringValue(e,"refreshToken",void 0),expiresAt:e.expiresAt?new Date(e.expiresAt):void 0,scopes:this.getArrayValue(e,"scopes",[])});case"basic":return u.createBasic(this.providerType,this.getStringValue(e,"username"),this.getStringValue(e,"password"));default:throw this.createAuthError(`Unsupported auth type: ${t}`,"UNSUPPORTED_AUTH_TYPE")}})}validateCredentials(e){return r.Effect.flatMap(e.validate(),t=>{if(!t)return r.Effect.succeed(!1);switch(e.type){case"pat":return this.validateGitHubPAT(e);case"oauth2":return this.validateGitHubOAuth2(e);case"basic":return this.validateGitHubBasic(e);default:return r.Effect.fail(this.createAuthError("Unknown auth type","UNKNOWN_AUTH_TYPE"))}})}getAuthHeaders(e){return r.Effect.sync(()=>{const t={Accept:"application/vnd.github+json","X-GitHub-Api-Version":"2022-11-28","User-Agent":"Skelegit/1.0.0"};switch(e.type){case"pat":t.Authorization=`token ${e.token}`;break;case"oauth2":t.Authorization=`Bearer ${e.accessToken}`;break;case"basic":{const a=globalThis.btoa(`${e.username}:${e.password}`);t.Authorization=`Basic ${a}`;break}default:throw this.createAuthError("Unknown auth type","UNKNOWN_AUTH_TYPE")}return t})}refreshCredentials(e){return e.type!=="oauth2"?r.Effect.fail(this.createAuthError("Refresh not supported for this auth type","REFRESH_NOT_SUPPORTED")):e.refreshToken?r.Effect.fail(this.createAuthError("OAuth2 refresh not implemented","NOT_IMPLEMENTED")):r.Effect.fail(this.createAuthError("No refresh token available","NO_REFRESH_TOKEN"))}handleAuthChallenge(e,t){return e.type==="totp"?r.Effect.fail(this.createAuthError("2FA challenge not implemented","NOT_IMPLEMENTED")):r.Effect.fail(this.createAuthError(`Unsupported challenge type: ${e.type}`,"UNSUPPORTED_CHALLENGE"))}validateGitHubPAT(e){return r.Effect.tryPromise({try:async()=>{const t=e.token;return!(!t.startsWith("ghp_")&&!t.startsWith("github_pat_"))},catch:t=>this.createAuthError("PAT validation failed","VALIDATION_ERROR",t)})}validateGitHubOAuth2(e){return r.Effect.tryPromise({try:async()=>!0,catch:t=>this.createAuthError("OAuth2 validation failed","VALIDATION_ERROR",t)})}validateGitHubBasic(e){return r.Effect.tryPromise({try:async()=>!0,catch:t=>this.createAuthError("Basic auth validation failed","VALIDATION_ERROR",t)})}}class A extends l{constructor(){super(...arguments),this.providerType="arweave",this.supportedAuthTypes=["web3-wallet","aes-key","anonymous"]}createCredentials(e){return r.Effect.sync(()=>{const t=this.getStringValue(e,"type");if(!this.isAuthTypeSupported(t))throw this.createAuthError(`Unsupported auth type: ${t}`,"UNSUPPORTED_AUTH_TYPE");switch(t){case"web3-wallet":return u.createWeb3Wallet({providerId:this.providerType,walletAddress:this.getStringValue(e,"walletAddress"),chainId:this.getNumberValue(e,"chainId",1),signature:this.getStringValue(e,"signature",void 0),nonce:this.getStringValue(e,"nonce",void 0),signMessage:a=>this.signMessage(a,e),getAddress:()=>this.getWalletAddress(e)});case"aes-key":return u.createAESKey({providerId:this.providerType,keyId:this.getStringValue(e,"keyId"),encryptedKey:this.getStringValue(e,"encryptedKey"),algorithm:e.algorithm,decrypt:a=>this.decryptData(a,e),encrypt:a=>this.encryptData(a,e)});case"anonymous":return u.createAnonymous(this.providerType);default:throw this.createAuthError(`Unsupported auth type: ${t}`,"UNSUPPORTED_AUTH_TYPE")}})}validateCredentials(e){return r.Effect.flatMap(e.validate(),t=>{if(!t)return r.Effect.succeed(!1);switch(e.type){case"web3-wallet":return this.validateArweaveWallet(e);case"aes-key":return this.validateArweaveKey(e);case"anonymous":return r.Effect.succeed(!0);default:return r.Effect.fail(this.createAuthError("Unknown auth type","UNKNOWN_AUTH_TYPE"))}})}getAuthHeaders(e){return r.Effect.sync(()=>{const t={"Content-Type":"application/json","User-Agent":"Skelegit/1.0.0"};switch(e.type){case"web3-wallet":t["X-Wallet-Address"]=e.walletAddress,e.signature&&(t["X-Wallet-Signature"]=e.signature),e.nonce&&(t["X-Nonce"]=e.nonce);break;case"aes-key":t["X-Key-ID"]=e.keyId;break;case"anonymous":break;default:throw this.createAuthError("Unknown auth type","UNKNOWN_AUTH_TYPE")}return t})}handleAuthChallenge(e,t){var a;if(e.type==="signature"&&t.type==="web3-wallet"){const s=(a=e.data)==null?void 0:a.message;return s?r.Effect.flatMap(t.signMessage(s),c=>{var o;return r.Effect.succeed({...t,signature:c,nonce:(o=e.data)==null?void 0:o.nonce})}):r.Effect.fail(this.createAuthError("No message to sign","MISSING_SIGNATURE_MESSAGE"))}return r.Effect.fail(this.createAuthError(`Unsupported challenge type: ${e.type}`,"UNSUPPORTED_CHALLENGE"))}signMessage(e,t){return r.Effect.tryPromise({try:async()=>{throw new Error("Wallet signing not implemented")},catch:a=>this.createAuthError("Message signing failed","SIGNING_ERROR",a)})}getWalletAddress(e){return r.Effect.tryPromise({try:async()=>this.getStringValue(e,"walletAddress"),catch:t=>this.createAuthError("Address retrieval failed","ADDRESS_ERROR",t)})}encryptData(e,t){return r.Effect.tryPromise({try:async()=>{throw new Error("AES encryption not implemented")},catch:a=>this.createAuthError("Encryption failed","ENCRYPTION_ERROR",a)})}decryptData(e,t){return r.Effect.tryPromise({try:async()=>{throw new Error("AES decryption not implemented")},catch:a=>this.createAuthError("Decryption failed","DECRYPTION_ERROR",a)})}validateArweaveWallet(e){return r.Effect.tryPromise({try:async()=>{const t=e.walletAddress;return!!/^[a-zA-Z0-9_-]{43}$/.test(t)},catch:t=>this.createAuthError("Wallet validation failed","VALIDATION_ERROR",t)})}validateArweaveKey(e){return r.Effect.tryPromise({try:async()=>!0,catch:t=>this.createAuthError("Key validation failed","VALIDATION_ERROR",t)})}}class d{constructor(){this.providers=new Map,this.credentials=new Map}registerProvider(e){return r.Effect.sync(()=>{this.providers.set(e.providerType,e)})}getProvider(e){return r.Effect.sync(()=>{const t=this.providers.get(e);if(!t)throw new n(`Provider not found: ${e}`,"PROVIDER_NOT_FOUND");return t})}createCredentials(e,t,a){return r.Effect.flatMap(this.getProvider(e),s=>r.Effect.flatMap(s.createCredentials(t),c=>r.Effect.flatMap(s.validateCredentials(c),o=>{if(!o)return r.Effect.fail(new n("Invalid credentials","INVALID_CREDENTIALS"));const h=a||this.generateCredentialId(e);return this.credentials.set(h,c),r.Effect.succeed(h)})))}getCredentials(e){return r.Effect.sync(()=>{const t=this.credentials.get(e);if(!t)throw new n(`Credentials not found: ${e}`,"CREDENTIALS_NOT_FOUND");return t})}createAuthContext(e,t){return r.Effect.flatMap(this.getCredentials(e),a=>r.Effect.flatMap(this.getProvider(a.providerId),s=>r.Effect.succeed({credentials:a,provider:s,metadata:t})))}getAuthHeaders(e){return r.Effect.flatMap(this.getCredentials(e),t=>r.Effect.flatMap(this.getProvider(t.providerId),a=>a.getAuthHeaders(t)))}refreshCredentials(e){return r.Effect.flatMap(this.getCredentials(e),t=>r.Effect.flatMap(this.getProvider(t.providerId),a=>a.refreshCredentials?r.Effect.flatMap(a.refreshCredentials(t),s=>r.Effect.sync(()=>{this.credentials.set(e,s)})):r.Effect.fail(new n("Refresh not supported","REFRESH_NOT_SUPPORTED"))))}validateCredentials(e){return r.Effect.flatMap(this.getCredentials(e),t=>r.Effect.flatMap(this.getProvider(t.providerId),a=>a.validateCredentials(t)))}removeCredentials(e){return r.Effect.sync(()=>this.credentials.delete(e))}listProviders(){return r.Effect.sync(()=>Array.from(this.providers.keys()))}listCredentials(){return r.Effect.sync(()=>Array.from(this.credentials.entries()).map(([e,t])=>({id:e,data:t.serialize()})))}getSupportedAuthTypes(e){return r.Effect.flatMap(this.getProvider(e),t=>r.Effect.succeed(t.supportedAuthTypes))}generateCredentialId(e){const t=Date.now(),a=Math.random().toString(36).substring(2,8);return`${e}-${t}-${a}`}}class f{constructor(e){this.plugins=new Map,this.authManager=e||new d}registerPlugin(e){return r.Effect.sync(()=>{this.plugins.set(e.provider,e)})}getPlugin(e){return r.Effect.sync(()=>{const t=this.plugins.get(e);if(!t)throw new Error(`Plugin not found for provider: ${e}`);return t})}createClient(e){return r.Effect.flatMap(this.getPlugin(e.provider),t=>t.createClient(e,this.authManager))}getAuthManager(){return this.authManager}listPlugins(){return r.Effect.sync(()=>Array.from(this.plugins.values()))}}const p=new f;function g(i){return p.createClient(i)}class v{constructor(){this.clients=new Map}addClient(e,t){return r.Effect.sync(()=>{this.clients.set(e,t)})}getClient(e){return r.Effect.sync(()=>{const t=this.clients.get(e);if(!t)throw new Error(`Client not found: ${e}`);return t})}removeClient(e){return r.Effect.sync(()=>this.clients.delete(e))}listClients(){return r.Effect.sync(()=>Array.from(this.clients.keys()))}}class y{constructor(e){this.config=e}getConfig(){return r.Effect.succeed(this.config)}getClientConfig(e){return r.Effect.sync(()=>{const t=this.config.clients[e];if(!t)throw new Error(`Client configuration not found: ${e}`);return t})}getDefaultClientConfig(){return r.Effect.sync(()=>{if(!this.config.defaultClient)throw new Error("No default client configured");return this.getClientConfig(this.config.defaultClient)}).pipe(r.Effect.flatten)}updateConfig(e){return r.Effect.sync(()=>{this.config={...this.config,...e}})}}function w(i){return new y(i)}exports.ArweaveAuthProvider=A;exports.AuthError=n;exports.AuthManager=d;exports.BaseAuthProvider=l;exports.ConfigManager=y;exports.CredentialFactory=u;exports.GitClientManager=v;exports.GitHubAuthProvider=E;exports.PluginSystem=f;exports.createConfigManager=w;exports.createGitClient=g;exports.pluginSystem=p;
